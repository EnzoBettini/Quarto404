<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quarto 404 - Prova de Conceito</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            /* Cor de fundo escura para a ambientação */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
        }

        #game-container {
            position: relative;
            /* Para posicionar o HUD sobre o canvas */
            width: 800px;
            /* Tamanho fixo para o canvas na POC */
            height: 600px;
            background-color: #000;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
        }

        canvas {
            display: block;
            /* Remove margem extra do canvas */
        }

        #game-hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 1.1em;
            color: #eee;
            z-index: 10;
            /* Garante que o HUD esteja acima do canvas */
            min-width: 150px;
            text-align: center;
        }

        #game-hud p {
            margin: 5px 0;
        }

        #message-box {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.2em;
            color: #fff;
            text-align: center;
            width: 60%;
            max-width: 500px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.9);
            z-index: 10;
            display: none;
            /* Escondido por padrão */
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div id="game-hud">
            <p>Fragmentos: {{ fragmentosColetados }}/{{ totalFragmentos }}</p>
            <p v-if="quarto404Aberto">Quarto 404: ABERTO</p>
            <p v-else>Quarto 404: TRANCADO</p>
        </div>
        <div id="message-box" style="display: none;">
            <p id="message-text"></p>
        </div>
    </div>

    <script>
        // Configurações do jogo
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_SPEED = 150;
        const TILE_SIZE = 50; // Tamanho de um "quadrado" virtual no mapa
        const ROOM_COUNT = 3; // Número de quartos para coletar fragmentos
        const DOOR_INTERACT_DISTANCE = 40; // Distância para interagir com a porta

        // Assets (placeholders por enquanto, em um jogo real seriam imagens)
        const ASSETS = {
            player: { key: 'player', color: 0x0000ff }, // Azul
            wall: { color: 0x555555 }, // Cinza escuro
            door: { color: 0x8B4513 }, // Marrom
            fragment: { color: 0xFFFF00 }, // Amarelo
            quarto404Door: { color: 0x800000 } // Vermelho escuro para a porta 404
        };

        // Estado global do jogo (acessível pelo Vue e Phaser)
        let gameState = {
            fragmentosColetados: 0,
            totalFragmentos: ROOM_COUNT,
            quarto404Aberto: false,
            // Para controlar quais quartos já foram visitados no ciclo atual
            visitedRooms: new Set(),
            currentRoomId: 'saguão' // Onde o jogador está atualmente
        };

        // Instância Vue para o HUD
        const app = new Vue({
            el: '#game-hud',
            data: gameState
        });

        // Controle da caixa de mensagens
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');

        function showMessage(text, duration = 2000) {
            messageText.textContent = text;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }

        // Cenário base do Phaser para o Saguão
        class SaguãoCena extends Phaser.Scene {
            constructor() {
                super('SaguãoCena');
                this.player = null;
                this.cursors = null;
                this.interactKey = null;
                this.doors = null; // Grupo de portas no saguão
                this.quarto404Door = null;
            }

            preload() {
                // Não há assets visuais reais aqui, apenas cores para as formas.
                // Em um jogo real, pré-carregaríamos spritesheets, imagens, etc.
            }

            create() {
                // Desenhar o chão
                this.add.rectangle(GAME_WIDTH / 2, GAME_HEIGHT / 2, GAME_WIDTH, GAME_HEIGHT, 0x333333).setOrigin(0.5);

                // Paredes do corredor (simplificado para uma prova de conceito)
                this.add.rectangle(GAME_WIDTH / 2, 25, GAME_WIDTH, TILE_SIZE, ASSETS.wall.color); // Parede superior
                this.add.rectangle(GAME_WIDTH / 2, GAME_HEIGHT - 25, GAME_WIDTH, TILE_SIZE, ASSETS.wall.color); // Parede inferior
                this.add.rectangle(25, GAME_HEIGHT / 2, TILE_SIZE, GAME_HEIGHT, ASSETS.wall.color); // Parede esquerda
                this.add.rectangle(GAME_WIDTH - 25, GAME_HEIGHT / 2, TILE_SIZE, GAME_HEIGHT, ASSETS.wall.color); // Parede direita

                // Posições das portas (simulando um corredor com portas)
                const doorPositions = [
                    { x: 150, y: GAME_HEIGHT / 2, roomId: 'quarto1' },
                    { x: 350, y: GAME_HEIGHT / 2, roomId: 'quarto2' },
                    { x: 550, y: GAME_HEIGHT / 2, roomId: 'quarto3' }
                ];

                this.doors = this.physics.add.staticGroup();
                doorPositions.forEach((pos, index) => {
                    const door = this.doors.create(pos.x, pos.y, 'door').setSize(TILE_SIZE, TILE_SIZE * 2); // Ajuste do tamanho
                    door.setData('roomId', pos.roomId);
                    door.setData('index', index + 1); // Para referência no visitedRooms
                    // Desenha o retângulo da porta
                    this.add.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE * 2, ASSETS.door.color).setOrigin(0.5);
                    this.add.text(pos.x, pos.y - 30, `Q${index + 1}`, { fontSize: '20px', fill: '#FFF' }).setOrigin(0.5);
                });

                // Porta 404 - sempre no final do corredor (lado direito na POC)
                this.quarto404Door = this.physics.add.staticSprite(GAME_WIDTH - 75, GAME_HEIGHT / 2, 'quarto404Door').setSize(TILE_SIZE, TILE_SIZE * 2);
                this.quarto404Door.setData('roomId', 'quarto404');
                this.add.rectangle(GAME_WIDTH - 75, GAME_HEIGHT / 2, TILE_SIZE, TILE_SIZE * 2, ASSETS.quarto404Door.color).setOrigin(0.5);
                this.add.text(GAME_WIDTH - 75, GAME_HEIGHT / 2 - 30, 'Q404', { fontSize: '20px', fill: '#FFF' }).setOrigin(0.5);


                // O jogador sempre começa no mesmo ponto
                this.player = this.physics.add.sprite(100, GAME_HEIGHT / 2, 'player').setOrigin(0.5).setSize(30, 30);
                this.add.rectangle(this.player.x, this.player.y, 30, 30, ASSETS.player.color).setOrigin(0.5);
                this.player.setCollideWorldBounds(true); // O jogador não pode sair da tela

                this.cursors = this.input.keyboard.createCursorKeys();
                this.interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

                // Lógica de interação com portas
                this.interactKey.on('down', () => {
                    this.doors.children.each(door => {
                        const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, door.x, door.y);
                        if (distance < DOOR_INTERACT_DISTANCE) {
                            const roomId = door.getData('roomId');
                            const roomIndex = door.getData('index');

                            if (gameState.visitedRooms.has(roomIndex)) {
                                showMessage(`Você já explorou o Quarto ${roomIndex} neste ciclo.`);
                            } else {
                                gameState.currentRoomId = roomId;
                                gameState.visitedRooms.add(roomIndex); // Marca como visitado
                                this.scene.start('QuartoCena', { roomId: roomId });
                            }
                        }
                    });

                    // Interação com a porta 404
                    const dist404 = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.quarto404Door.x, this.quarto404Door.y);
                    if (dist404 < DOOR_INTERACT_DISTANCE && gameState.quarto404Aberto) {
                        showMessage("A porta do Quarto 404 range e se abre, revelando um vazio perturbador...");
                        // Simula o final do jogo / reset
                        setTimeout(() => {
                            this.scene.start('FimDeCicloCena');
                        }, 2000);
                    } else if (dist404 < DOOR_INTERACT_DISTANCE && !gameState.quarto404Aberto) {
                        showMessage("A porta do Quarto 404 está trancada. Você precisa coletar mais fragmentos.");
                    }
                });

                // Reinicia o estado do jogo ao iniciar a cena (novo ciclo)
                this.resetGameCycle();
            }

            resetGameCycle() {
                gameState.fragmentosColetados = 0;
                gameState.quarto404Aberto = false;
                gameState.visitedRooms.clear(); // Limpa quartos visitados
                showMessage("Você acorda no saguão. Explore os quartos.");
            }

            update() {
                this.player.body.setVelocity(0);

                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-PLAYER_SPEED);
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(PLAYER_SPEED);
                }

                if (this.cursors.up.isDown) {
                    this.player.body.setVelocityY(-PLAYER_SPEED);
                } else if (this.cursors.down.isDown) {
                    this.player.body.setVelocityY(PLAYER_SPEED);
                }

                // Atualiza a posição do retângulo do player para simular o sprite
                const playerRect = this.children.getByName('playerRect');
                if (playerRect) {
                    playerRect.x = this.player.x;
                    playerRect.y = this.player.y;
                } else {
                    // Cria o retângulo se ainda não existir
                    const rect = this.add.rectangle(this.player.x, this.player.y, 30, 30, ASSETS.player.color).setOrigin(0.5);
                    rect.setName('playerRect');
                }
            }
        }

        // Cenário para os quartos (genérico, para simular diferentes quartos)
        class QuartoCena extends Phaser.Scene {
            constructor() {
                super('QuartoCena');
                this.player = null;
                this.cursors = null;
                this.interactKey = null;
                this.roomId = null;
                this.fragment = null;
                this.fragmentCollectedInThisRoom = false;
            }

            init(data) {
                this.roomId = data.roomId;
                this.fragmentCollectedInThisRoom = false; // Garante que cada quarto tem seu fragmento por ciclo
            }

            create() {
                // Simula o interior do quarto
                this.add.rectangle(GAME_WIDTH / 2, GAME_HEIGHT / 2, GAME_WIDTH * 0.9, GAME_HEIGHT * 0.9, 0x111111).setOrigin(0.5);
                this.add.text(GAME_WIDTH / 2, 50, `Você está no ${this.roomId.toUpperCase()}`, { fontSize: '28px', fill: '#FFF' }).setOrigin(0.5);

                // Adiciona um fragmento (simbolizado por um quadrado amarelo)
                const fragmentX = Phaser.Math.Between(100, GAME_WIDTH - 100);
                const fragmentY = Phaser.Math.Between(150, GAME_HEIGHT - 100);
                this.fragment = this.physics.add.sprite(fragmentX, fragmentY, 'fragment').setSize(20, 20);
                this.add.rectangle(this.fragment.x, this.fragment.y, 20, 20, ASSETS.fragment.color).setOrigin(0.5).setName('fragmentRect');


                // Player volta para o centro do quarto (apenas para POC, ideal seria em uma porta)
                this.player = this.physics.add.sprite(GAME_WIDTH / 2, GAME_HEIGHT - 100, 'player').setOrigin(0.5).setSize(30, 30);
                this.player.setCollideWorldBounds(true);

                this.cursors = this.input.keyboard.createCursorKeys();
                this.interactKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

                // Jumpscare rudimentar (exemplo: flash na tela e som, sem assets, apenas texto)
                if (Phaser.Math.Between(0, 100) < 30) { // 30% de chance
                    this.time.delayedCall(Phaser.Math.Between(500, 2000), () => {
                        this.cameras.main.flash(500, 255, 255, 255); // Flash branco
                        showMessage("Um calafrio percorre sua espinha!");
                    }, [], this);
                }

                // Lógica de interação com fragmento
                this.interactKey.on('down', () => {
                    const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.fragment.x, this.fragment.y);
                    if (distance < DOOR_INTERACT_DISTANCE && !this.fragmentCollectedInThisRoom) {
                        this.fragmentCollectedInThisRoom = true;
                        this.fragment.destroy(); // Remove o fragmento
                        this.children.getByName('fragmentRect').destroy(); // Remove o retângulo visual
                        gameState.fragmentosColetados++;
                        showMessage("Você coletou um fragmento!");

                        if (gameState.fragmentosColetados >= gameState.totalFragmentos) {
                            gameState.quarto404Aberto = true;
                            showMessage("Você sente a porta do Quarto 404 vibrar. Ela pode ser aberta agora.", 3000);
                        }
                    }
                });

                // Botão de voltar para o saguão (simulado)
                this.add.text(GAME_WIDTH / 2, GAME_HEIGHT - 50, 'Pressione Q para Voltar ao Saguão', { fontSize: '18px', fill: '#CCC' })
                    .setOrigin(0.5)
                    .setInteractive()
                    .on('pointerdown', () => this.scene.start('SaguãoCena'));

                this.input.keyboard.on('keydown-Q', () => this.scene.start('SaguãoCena'));
            }

            update() {
                this.player.body.setVelocity(0);

                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-PLAYER_SPEED);
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(PLAYER_SPEED);
                }

                if (this.cursors.up.isDown) {
                    this.player.body.setVelocityY(-PLAYER_SPEED);
                } else if (this.cursors.down.isDown) {
                    this.player.body.setVelocityY(PLAYER_SPEED);
                }

                // Atualiza a posição do retângulo do player
                const playerRect = this.children.getByName('playerRect');
                if (playerRect) {
                    playerRect.x = this.player.x;
                    playerRect.y = this.player.y;
                } else {
                    const rect = this.add.rectangle(this.player.x, this.player.y, 30, 30, ASSETS.player.color).setOrigin(0.5);
                    rect.setName('playerRect');
                }
            }
        }

        // Cenário de Fim de Ciclo (para a revelação do Quarto 404)
        class FimDeCicloCena extends Phaser.Scene {
            constructor() {
                super('FimDeCicloCena');
            }

            create() {
                this.cameras.main.setBackgroundColor('#000');
                this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50, 'A VERDADE É REVELADA...', { fontSize: '32px', fill: '#FF0000' })
                    .setOrigin(0.5);
                this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2, 'Você é o monstro.', { fontSize: '24px', fill: '#FF0000' })
                    .setOrigin(0.5);
                this.add.text(GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50, 'Tudo escurece...', { fontSize: '20px', fill: '#AAA' })
                    .setOrigin(0.5);

                // Simula o ciclo eterno
                this.time.delayedCall(4000, () => {
                    this.scene.start('SaguãoCena'); // Volta para o saguão, reiniciando o ciclo
                }, [], this);
            }
        }

        // Configuração do jogo Phaser
        const config = {
            type: Phaser.AUTO,
            width: GAME_WIDTH,
            height: GAME_HEIGHT,
            parent: 'game-container', // Renderiza o canvas dentro da div game-container
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false // Defina como true para ver os bodies de colisão
                }
            },
            scene: [SaguãoCena, QuartoCena, FimDeCicloCena]
        };

        const game = new Phaser.Game(config);

    </script>
</body>

</html>
